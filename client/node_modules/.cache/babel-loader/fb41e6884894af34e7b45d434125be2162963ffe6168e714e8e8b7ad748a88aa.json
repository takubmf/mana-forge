{"ast":null,"code":"import { __assign, __spreadArray } from \"tslib\";\nimport { invariant } from \"../globals/index.js\";\nimport { visit, Kind } from 'graphql';\nimport { checkDocument, getOperationDefinition, getFragmentDefinition, getFragmentDefinitions, getMainDefinition } from \"./getFromAST.js\";\nimport { isField } from \"./storeUtils.js\";\nimport { createFragmentMap } from \"./fragments.js\";\nimport { isArray } from \"../common/arrays.js\";\nvar TYPENAME_FIELD = {\n  kind: Kind.FIELD,\n  name: {\n    kind: Kind.NAME,\n    value: '__typename'\n  }\n};\nfunction isEmpty(op, fragmentMap) {\n  return !op || op.selectionSet.selections.every(function (selection) {\n    return selection.kind === Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap);\n  });\n}\nfunction nullIfDocIsEmpty(doc) {\n  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;\n}\nfunction getDirectiveMatcher(directives) {\n  var nameSet = new Set();\n  var tests = [];\n  directives.forEach(function (directive) {\n    if (directive.name) {\n      nameSet.add(directive.name);\n    } else if (directive.test) {\n      tests.push(directive.test);\n    }\n  });\n  return function (directive) {\n    return nameSet.has(directive.name.value) || tests.some(function (test) {\n      return test(directive);\n    });\n  };\n}\nfunction makeInUseGetterFunction(defaultKey) {\n  var map = new Map();\n  return function inUseGetterFunction(key) {\n    if (key === void 0) {\n      key = defaultKey;\n    }\n    var inUse = map.get(key);\n    if (!inUse) {\n      map.set(key, inUse = {\n        variables: new Set(),\n        fragmentSpreads: new Set()\n      });\n    }\n    return inUse;\n  };\n}\nexport function removeDirectivesFromDocument(directives, doc) {\n  var getInUseByOperationName = makeInUseGetterFunction(\"\");\n  var getInUseByFragmentName = makeInUseGetterFunction(\"\");\n  var getInUse = function (ancestors) {\n    for (var p = 0, ancestor = void 0; p < ancestors.length && (ancestor = ancestors[p]); ++p) {\n      if (isArray(ancestor)) continue;\n      if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n        return getInUseByOperationName(ancestor.name && ancestor.name.value);\n      }\n      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n        return getInUseByFragmentName(ancestor.name.value);\n      }\n    }\n    __DEV__ && invariant.error(\"Could not find operation or fragment\");\n    return null;\n  };\n  var operationCount = 0;\n  for (var i = doc.definitions.length - 1; i >= 0; --i) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      ++operationCount;\n    }\n  }\n  var directiveMatcher = getDirectiveMatcher(directives);\n  var hasRemoveDirective = directives.some(function (directive) {\n    return directive.remove;\n  });\n  var shouldRemoveField = function (nodeDirectives) {\n    return hasRemoveDirective && nodeDirectives && nodeDirectives.some(directiveMatcher);\n  };\n  var originalFragmentDefsByPath = new Map();\n  var firstVisitMadeChanges = false;\n  var fieldOrInlineFragmentVisitor = {\n    enter: function (node) {\n      if (shouldRemoveField(node.directives)) {\n        firstVisitMadeChanges = true;\n        return null;\n      }\n    }\n  };\n  var docWithoutDirectiveSubtrees = visit(doc, {\n    Field: fieldOrInlineFragmentVisitor,\n    InlineFragment: fieldOrInlineFragmentVisitor,\n    VariableDefinition: {\n      enter: function () {\n        return false;\n      }\n    },\n    Variable: {\n      enter: function (node, _key, _parent, _path, ancestors) {\n        var inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.variables.add(node.name.value);\n        }\n      }\n    },\n    FragmentSpread: {\n      enter: function (node, _key, _parent, _path, ancestors) {\n        if (shouldRemoveField(node.directives)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n        var inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.fragmentSpreads.add(node.name.value);\n        }\n      }\n    },\n    FragmentDefinition: {\n      enter: function (node, _key, _parent, path) {\n        originalFragmentDefsByPath.set(JSON.stringify(path), node);\n      },\n      leave: function (node, _key, _parent, path) {\n        var originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));\n        if (node === originalNode) {\n          return node;\n        }\n        if (operationCount > 0 && node.selectionSet.selections.every(function (selection) {\n          return selection.kind === Kind.FIELD && selection.name.value === '__typename';\n        })) {\n          getInUseByFragmentName(node.name.value).removed = true;\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      }\n    },\n    Directive: {\n      leave: function (node) {\n        if (directiveMatcher(node)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      }\n    }\n  });\n  if (!firstVisitMadeChanges) {\n    return doc;\n  }\n  var populateTransitiveVars = function (inUse) {\n    if (!inUse.transitiveVars) {\n      inUse.transitiveVars = new Set(inUse.variables);\n      if (!inUse.removed) {\n        inUse.fragmentSpreads.forEach(function (childFragmentName) {\n          populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach(function (varName) {\n            inUse.transitiveVars.add(varName);\n          });\n        });\n      }\n    }\n    return inUse;\n  };\n  var allFragmentNamesUsed = new Set();\n  docWithoutDirectiveSubtrees.definitions.forEach(function (def) {\n    if (def.kind === Kind.OPERATION_DEFINITION) {\n      populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach(function (childFragmentName) {\n        allFragmentNamesUsed.add(childFragmentName);\n      });\n    } else if (def.kind === Kind.FRAGMENT_DEFINITION && operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {\n      allFragmentNamesUsed.add(def.name.value);\n    }\n  });\n  allFragmentNamesUsed.forEach(function (fragmentName) {\n    populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach(function (childFragmentName) {\n      allFragmentNamesUsed.add(childFragmentName);\n    });\n  });\n  var fragmentWillBeRemoved = function (fragmentName) {\n    return !!(!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);\n  };\n  var enterVisitor = {\n    enter: function (node) {\n      if (fragmentWillBeRemoved(node.name.value)) {\n        return null;\n      }\n    }\n  };\n  return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {\n    FragmentSpread: enterVisitor,\n    FragmentDefinition: enterVisitor,\n    OperationDefinition: {\n      leave: function (node) {\n        if (node.variableDefinitions) {\n          var usedVariableNames_1 = populateTransitiveVars(getInUseByOperationName(node.name && node.name.value)).transitiveVars;\n          if (usedVariableNames_1.size < node.variableDefinitions.length) {\n            return __assign(__assign({}, node), {\n              variableDefinitions: node.variableDefinitions.filter(function (varDef) {\n                return usedVariableNames_1.has(varDef.variable.name.value);\n              })\n            });\n          }\n        }\n      }\n    }\n  }));\n}\nexport var addTypenameToDocument = Object.assign(function (doc) {\n  return visit(doc, {\n    SelectionSet: {\n      enter: function (node, _key, parent) {\n        if (parent && parent.kind === Kind.OPERATION_DEFINITION) {\n          return;\n        }\n        var selections = node.selections;\n        if (!selections) {\n          return;\n        }\n        var skip = selections.some(function (selection) {\n          return isField(selection) && (selection.name.value === '__typename' || selection.name.value.lastIndexOf('__', 0) === 0);\n        });\n        if (skip) {\n          return;\n        }\n        var field = parent;\n        if (isField(field) && field.directives && field.directives.some(function (d) {\n          return d.name.value === 'export';\n        })) {\n          return;\n        }\n        return __assign(__assign({}, node), {\n          selections: __spreadArray(__spreadArray([], selections, true), [TYPENAME_FIELD], false)\n        });\n      }\n    }\n  });\n}, {\n  added: function (field) {\n    return field === TYPENAME_FIELD;\n  }\n});\nvar connectionRemoveConfig = {\n  test: function (directive) {\n    var willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (!directive.arguments || !directive.arguments.some(function (arg) {\n        return arg.name.value === 'key';\n      })) {\n        __DEV__ && invariant.warn('Removing an @connection directive even though it does not have a key. ' + 'You may want to use the key parameter to specify a store key.');\n      }\n    }\n    return willRemove;\n  }\n};\nexport function removeConnectionDirectiveFromDocument(doc) {\n  return removeDirectivesFromDocument([connectionRemoveConfig], checkDocument(doc));\n}\nfunction hasDirectivesInSelectionSet(directives, selectionSet, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n  return !!selectionSet && selectionSet.selections && selectionSet.selections.some(function (selection) {\n    return hasDirectivesInSelection(directives, selection, nestedCheck);\n  });\n}\nfunction hasDirectivesInSelection(directives, selection, nestedCheck) {\n  if (nestedCheck === void 0) {\n    nestedCheck = true;\n  }\n  if (!isField(selection)) {\n    return true;\n  }\n  if (!selection.directives) {\n    return false;\n  }\n  return selection.directives.some(getDirectiveMatcher(directives)) || nestedCheck && hasDirectivesInSelectionSet(directives, selection.selectionSet, nestedCheck);\n}\nfunction getArgumentMatcher(config) {\n  return function argumentMatcher(argument) {\n    return config.some(function (aConfig) {\n      return argument.value && argument.value.kind === Kind.VARIABLE && argument.value.name && (aConfig.name === argument.value.name.value || aConfig.test && aConfig.test(argument));\n    });\n  };\n}\nexport function removeArgumentsFromDocument(config, doc) {\n  var argMatcher = getArgumentMatcher(config);\n  return nullIfDocIsEmpty(visit(doc, {\n    OperationDefinition: {\n      enter: function (node) {\n        return __assign(__assign({}, node), {\n          variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(function (varDef) {\n            return !config.some(function (arg) {\n              return arg.name === varDef.variable.name.value;\n            });\n          }) : []\n        });\n      }\n    },\n    Field: {\n      enter: function (node) {\n        var shouldRemoveField = config.some(function (argConfig) {\n          return argConfig.remove;\n        });\n        if (shouldRemoveField) {\n          var argMatchCount_1 = 0;\n          if (node.arguments) {\n            node.arguments.forEach(function (arg) {\n              if (argMatcher(arg)) {\n                argMatchCount_1 += 1;\n              }\n            });\n          }\n          if (argMatchCount_1 === 1) {\n            return null;\n          }\n        }\n      }\n    },\n    Argument: {\n      enter: function (node) {\n        if (argMatcher(node)) {\n          return null;\n        }\n      }\n    }\n  }));\n}\nexport function removeFragmentSpreadFromDocument(config, doc) {\n  function enter(node) {\n    if (config.some(function (def) {\n      return def.name === node.name.value;\n    })) {\n      return null;\n    }\n  }\n  return nullIfDocIsEmpty(visit(doc, {\n    FragmentSpread: {\n      enter: enter\n    },\n    FragmentDefinition: {\n      enter: enter\n    }\n  }));\n}\nexport function buildQueryFromSelectionSet(document) {\n  var definition = getMainDefinition(document);\n  var definitionOperation = definition.operation;\n  if (definitionOperation === 'query') {\n    return document;\n  }\n  var modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter: function (node) {\n        return __assign(__assign({}, node), {\n          operation: 'query'\n        });\n      }\n    }\n  });\n  return modifiedDoc;\n}\nexport function removeClientSetsFromDocument(document) {\n  checkDocument(document);\n  var modifiedDoc = removeDirectivesFromDocument([{\n    test: function (directive) {\n      return directive.name.value === 'client';\n    },\n    remove: true\n  }], document);\n  return modifiedDoc;\n}","map":{"version":3,"mappings":"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","names":["invariant","visit","Kind","checkDocument","getOperationDefinition","getFragmentDefinition","getFragmentDefinitions","getMainDefinition","isField","createFragmentMap","isArray","TYPENAME_FIELD","kind","FIELD","name","NAME","value","isEmpty","op","fragmentMap","selectionSet","selections","every","FRAGMENT_SPREAD","selection","nullIfDocIsEmpty","doc","getDirectiveMatcher","directives","nameSet","Set","tests","forEach","directive","add","test","push","has","some","makeInUseGetterFunction","defaultKey","map","Map","inUseGetterFunction","key","inUse","get","set","variables","fragmentSpreads","removeDirectivesFromDocument","getInUseByOperationName","getInUseByFragmentName","getInUse","ancestors","p","ancestor","length","OPERATION_DEFINITION","FRAGMENT_DEFINITION","__DEV__","operationCount","i","definitions","directiveMatcher","hasRemoveDirective","remove","shouldRemoveField","nodeDirectives","originalFragmentDefsByPath","firstVisitMadeChanges","fieldOrInlineFragmentVisitor","enter","node","docWithoutDirectiveSubtrees","Field","InlineFragment","VariableDefinition","Variable","_key","_parent","_path","FragmentSpread","FragmentDefinition","path","JSON","stringify","leave","originalNode","removed","Directive","populateTransitiveVars","transitiveVars","childFragmentName","varName","allFragmentNamesUsed","def","fragmentName","fragmentWillBeRemoved","enterVisitor","OperationDefinition","variableDefinitions","usedVariableNames_1","size","filter","varDef","variable","addTypenameToDocument","Object","assign","SelectionSet","parent","skip","lastIndexOf","field","added","connectionRemoveConfig","willRemove","arguments","removeConnectionDirectiveFromDocument","hasDirectivesInSelectionSet","nestedCheck","hasDirectivesInSelection","getArgumentMatcher","config","argumentMatcher","argument","aConfig","VARIABLE","removeArgumentsFromDocument","argMatcher","argMatchCount_1","arg","Argument","removeFragmentSpreadFromDocument","buildQueryFromSelectionSet","document","definition","definitionOperation","operation","modifiedDoc","removeClientSetsFromDocument"],"sources":["C:\\Users\\Fistycuffs\\mana-forge\\client\\node_modules\\@apollo\\src\\utilities\\graphql\\transform.ts"],"sourcesContent":["import { invariant } from '../globals';\n\nimport {\n  DocumentNode,\n  SelectionNode,\n  SelectionSetNode,\n  OperationDefinitionNode,\n  FieldNode,\n  DirectiveNode,\n  FragmentDefinitionNode,\n  ArgumentNode,\n  FragmentSpreadNode,\n  VariableDefinitionNode,\n  visit,\n  ASTNode,\n  Kind,\n  ASTVisitor,\n  InlineFragmentNode,\n} from 'graphql';\n\nimport {\n  checkDocument,\n  getOperationDefinition,\n  getFragmentDefinition,\n  getFragmentDefinitions,\n  getMainDefinition,\n} from './getFromAST';\nimport { isField } from './storeUtils';\nimport {\n  createFragmentMap,\n  FragmentMap,\n} from './fragments';\nimport { isArray } from '../common/arrays';\n\nexport type RemoveNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n  remove?: boolean;\n};\n\nexport type GetNodeConfig<N> = {\n  name?: string;\n  test?: (node: N) => boolean;\n};\n\nexport type RemoveDirectiveConfig = RemoveNodeConfig<DirectiveNode>;\nexport type GetDirectiveConfig = GetNodeConfig<DirectiveNode>;\nexport type RemoveArgumentsConfig = RemoveNodeConfig<ArgumentNode>;\nexport type GetFragmentSpreadConfig = GetNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentSpreadConfig = RemoveNodeConfig<FragmentSpreadNode>;\nexport type RemoveFragmentDefinitionConfig = RemoveNodeConfig<\n  FragmentDefinitionNode\n>;\nexport type RemoveVariableDefinitionConfig = RemoveNodeConfig<\n  VariableDefinitionNode\n>;\n\nconst TYPENAME_FIELD: FieldNode = {\n  kind: Kind.FIELD,\n  name: {\n    kind: Kind.NAME,\n    value: '__typename',\n  },\n};\n\nfunction isEmpty(\n  op: OperationDefinitionNode | FragmentDefinitionNode,\n  fragmentMap: FragmentMap,\n): boolean {\n  return !op || op.selectionSet.selections.every(\n    selection => selection.kind === Kind.FRAGMENT_SPREAD &&\n      isEmpty(fragmentMap[selection.name.value], fragmentMap)\n  );\n}\n\nfunction nullIfDocIsEmpty(doc: DocumentNode) {\n  return isEmpty(\n    getOperationDefinition(doc) || getFragmentDefinition(doc),\n    createFragmentMap(getFragmentDefinitions(doc)),\n  )\n    ? null\n    : doc;\n}\n\nfunction getDirectiveMatcher(\n  directives: (RemoveDirectiveConfig | GetDirectiveConfig)[],\n) {\n  const nameSet = new Set<string>();\n  const tests: Array<(directive: DirectiveNode) => boolean> = [];\n  directives.forEach(directive => {\n    if (directive.name) {\n      nameSet.add(directive.name);\n    } else if (directive.test) {\n      tests.push(directive.test);\n    }\n  });\n\n  return (directive: DirectiveNode) => (\n    nameSet.has(directive.name.value) ||\n    tests.some(test => test(directive))\n  );\n}\n\n// Helper interface and function used by removeDirectivesFromDocument to keep\n// track of variable references and fragments spreads found within a given\n// operation or fragment definition.\ninterface InternalInUseInfo {\n  variables: Set<string>;\n  fragmentSpreads: Set<string>;\n  // Set to true when we deliberately remove a fragment definition, so we can\n  // make sure also to remove dangling ...spreads that refer to it.\n  removed?: boolean;\n  // Populated by the populateTransitiveVars helper function below.\n  transitiveVars?: Set<string>;\n}\nfunction makeInUseGetterFunction<TKey>(defaultKey: TKey) {\n  const map = new Map<TKey, InternalInUseInfo>();\n\n  return function inUseGetterFunction(\n    key: TKey = defaultKey\n  ): InternalInUseInfo {\n    let inUse = map.get(key);\n    if (!inUse) {\n      map.set(key, inUse = {\n        // Variable and fragment spread names used directly within this\n        // operation or fragment definition, as identified by key. These sets\n        // will be populated during the first traversal of the document in\n        // removeDirectivesFromDocument below.\n        variables: new Set,\n        fragmentSpreads: new Set,\n      });\n    }\n    return inUse;\n  };\n}\n\nexport function removeDirectivesFromDocument(\n  directives: RemoveDirectiveConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  // Passing empty strings to makeInUseGetterFunction means we handle anonymous\n  // operations as if their names were \"\". Anonymous fragment definitions are\n  // not supposed to be possible, but the same default naming strategy seems\n  // appropriate for that case as well.\n  const getInUseByOperationName = makeInUseGetterFunction<string>(\"\");\n  const getInUseByFragmentName = makeInUseGetterFunction<string>(\"\");\n  const getInUse = (\n    ancestors: readonly (ASTNode | readonly ASTNode[])[],\n  ): InternalInUseInfo | null => {\n    for (\n      let p = 0, ancestor: ASTNode | readonly ASTNode[];\n      p < ancestors.length && (ancestor = ancestors[p]);\n      ++p\n    ) {\n      if (isArray(ancestor)) continue;\n      if (ancestor.kind === Kind.OPERATION_DEFINITION) {\n        // If an operation is anonymous, we use the empty string as its key.\n        return getInUseByOperationName(ancestor.name && ancestor.name.value);\n      }\n      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {\n        return getInUseByFragmentName(ancestor.name.value);\n      }\n    }\n    invariant.error(`Could not find operation or fragment`);\n    return null;\n  };\n\n  let operationCount = 0;\n  for (let i = doc.definitions.length - 1; i >= 0; --i) {\n    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {\n      ++operationCount;\n    }\n  }\n\n  const directiveMatcher = getDirectiveMatcher(directives);\n  const hasRemoveDirective = directives.some(directive => directive.remove);\n  const shouldRemoveField = (\n    nodeDirectives: FieldNode[\"directives\"]\n  ) => (\n    hasRemoveDirective &&\n    nodeDirectives &&\n    nodeDirectives.some(directiveMatcher)\n  );\n\n  const originalFragmentDefsByPath = new Map<string, FragmentDefinitionNode>();\n\n  // Any time the first traversal of the document below makes a change like\n  // removing a fragment (by returning null), this variable should be set to\n  // true. Once it becomes true, it should never be set to false again. If this\n  // variable remains false throughout the traversal, then we can return the\n  // original doc immediately without any modifications.\n  let firstVisitMadeChanges = false;\n\n  const fieldOrInlineFragmentVisitor: ASTVisitor = {\n    enter(node: FieldNode | InlineFragmentNode) {\n      if (shouldRemoveField(node.directives)) {\n        firstVisitMadeChanges = true;\n        return null;\n      }\n    },\n  };\n\n  const docWithoutDirectiveSubtrees = visit(doc, {\n    // These two AST node types share the same implementation, defined above.\n    Field: fieldOrInlineFragmentVisitor,\n    InlineFragment: fieldOrInlineFragmentVisitor,\n\n    VariableDefinition: {\n      enter() {\n        // VariableDefinition nodes do not count as variables in use, though\n        // they do contain Variable nodes that might be visited below. To avoid\n        // counting variable declarations as usages, we skip visiting the\n        // contents of this VariableDefinition node by returning false.\n        return false;\n      },\n    },\n\n    Variable: {\n      enter(node, _key, _parent, _path, ancestors) {\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.variables.add(node.name.value);\n        }\n      },\n    },\n\n    FragmentSpread: {\n      enter(node, _key, _parent, _path, ancestors) {\n        if (shouldRemoveField(node.directives)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n        const inUse = getInUse(ancestors);\n        if (inUse) {\n          inUse.fragmentSpreads.add(node.name.value);\n        }\n        // We might like to remove this FragmentSpread by returning null here if\n        // the corresponding FragmentDefinition node is also going to be removed\n        // by the logic below, but we can't control the relative order of those\n        // events, so we have to postpone the removal of dangling FragmentSpread\n        // nodes until after the current visit of the document has finished.\n      },\n    },\n\n    FragmentDefinition: {\n      enter(node, _key, _parent, path) {\n        originalFragmentDefsByPath.set(JSON.stringify(path), node);\n      },\n      leave(node, _key, _parent, path) {\n        const originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));\n        if (node === originalNode) {\n          // If the FragmentNode received by this leave function is identical to\n          // the one received by the corresponding enter function (above), then\n          // the visitor must not have made any changes within this\n          // FragmentDefinition node. This fragment definition may still be\n          // removed if there are no ...spread references to it, but it won't be\n          // removed just because it has only a __typename field.\n          return node;\n        }\n\n        if (\n          // This logic applies only if the document contains one or more\n          // operations, since removing all fragments from a document containing\n          // only fragments makes the document useless.\n          operationCount > 0 &&\n          node.selectionSet.selections.every(selection => (\n            selection.kind === Kind.FIELD &&\n            selection.name.value === '__typename'\n          ))\n        ) {\n          // This is a somewhat opinionated choice: if a FragmentDefinition ends\n          // up having no fields other than __typename, we remove the whole\n          // fragment definition, and later prune ...spread references to it.\n          getInUseByFragmentName(node.name.value).removed = true;\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n\n    Directive: {\n      leave(node) {\n        // If a matching directive is found, remove the directive itself. Note\n        // that this does not remove the target (field, argument, etc) of the\n        // directive, but only the directive itself.\n        if (directiveMatcher(node)) {\n          firstVisitMadeChanges = true;\n          return null;\n        }\n      },\n    },\n  });\n\n  if (!firstVisitMadeChanges) {\n    // If our first pass did not change anything about the document, then there\n    // is no cleanup we need to do, and we can return the original doc.\n    return doc;\n  }\n\n  // Utility for making sure inUse.transitiveVars is recursively populated.\n  // Because this logic assumes inUse.fragmentSpreads has been completely\n  // populated and inUse.removed has been set if appropriate,\n  // populateTransitiveVars must be called after that information has been\n  // collected by the first traversal of the document.\n  const populateTransitiveVars = (\n    inUse: InternalInUseInfo,\n  ) => {\n    if (!inUse.transitiveVars) {\n      inUse.transitiveVars = new Set(inUse.variables);\n      if (!inUse.removed) {\n        inUse.fragmentSpreads.forEach(childFragmentName => {\n          populateTransitiveVars(\n            getInUseByFragmentName(childFragmentName)\n          ).transitiveVars!.forEach(varName => {\n            inUse.transitiveVars!.add(varName);\n          });\n        });\n      }\n    }\n    return inUse;\n  };\n\n  // Since we've been keeping track of fragment spreads used by particular\n  // operations and fragment definitions, we now need to compute the set of all\n  // spreads used (transitively) by any operations in the document.\n  const allFragmentNamesUsed = new Set<string>();\n  docWithoutDirectiveSubtrees.definitions.forEach(def => {\n    if (def.kind === Kind.OPERATION_DEFINITION) {\n      populateTransitiveVars(\n        getInUseByOperationName(def.name && def.name.value)\n      ).fragmentSpreads.forEach(childFragmentName => {\n        allFragmentNamesUsed.add(childFragmentName);\n      });\n    } else if (\n      def.kind === Kind.FRAGMENT_DEFINITION &&\n      // If there are no operations in the document, then all fragment\n      // definitions count as usages of their own fragment names. This heuristic\n      // prevents accidentally removing all fragment definitions from the\n      // document just because it contains no operations that use the fragments.\n      operationCount === 0 &&\n      !getInUseByFragmentName(def.name.value).removed\n    ) {\n      allFragmentNamesUsed.add(def.name.value);\n    }\n  });\n  // Now that we have added all fragment spreads used by operations to the\n  // allFragmentNamesUsed set, we can complete the set by transitively adding\n  // all fragment spreads used by those fragments, and so on.\n  allFragmentNamesUsed.forEach(fragmentName => {\n    // Once all the childFragmentName strings added here have been seen already,\n    // the top-level allFragmentNamesUsed.forEach loop will terminate.\n    populateTransitiveVars(\n      getInUseByFragmentName(fragmentName)\n    ).fragmentSpreads.forEach(childFragmentName => {\n      allFragmentNamesUsed.add(childFragmentName);\n    });\n  });\n\n  const fragmentWillBeRemoved = (\n    fragmentName: string,\n  ) => !!(\n    // A fragment definition will be removed if there are no spreads that refer\n    // to it, or the fragment was explicitly removed because it had no fields\n    // other than __typename.\n    !allFragmentNamesUsed.has(fragmentName) ||\n    getInUseByFragmentName(fragmentName).removed\n  );\n\n  const enterVisitor: ASTVisitor = {\n    enter(node: FragmentSpreadNode | FragmentDefinitionNode) {\n      if (fragmentWillBeRemoved(node.name.value)) {\n        return null;\n      }\n    },\n  };\n\n  return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {\n    // If the fragment is going to be removed, then leaving any dangling\n    // FragmentSpread nodes with the same name would be a mistake.\n    FragmentSpread: enterVisitor,\n\n    // This is where the fragment definition is actually removed.\n    FragmentDefinition: enterVisitor,\n\n    OperationDefinition: {\n      leave(node) {\n        // Upon leaving each operation in the depth-first AST traversal, prune\n        // any variables that are declared by the operation but unused within.\n        if (node.variableDefinitions) {\n          const usedVariableNames = populateTransitiveVars(\n            // If an operation is anonymous, we use the empty string as its key.\n            getInUseByOperationName(node.name && node.name.value)\n          ).transitiveVars!;\n\n          // According to the GraphQL spec, all variables declared by an\n          // operation must either be used by that operation or used by some\n          // fragment included transitively into that operation:\n          // https://spec.graphql.org/draft/#sec-All-Variables-Used\n          //\n          // To stay on the right side of this validation rule, if/when we\n          // remove the last $var references from an operation or its fragments,\n          // we must also remove the corresponding $var declaration from the\n          // enclosing operation. This pruning applies only to operations and\n          // not fragment definitions, at the moment. Fragments may be able to\n          // declare variables eventually, but today they can only consume them.\n          if (usedVariableNames.size < node.variableDefinitions.length) {\n            return {\n              ...node,\n              variableDefinitions: node.variableDefinitions.filter(\n                varDef => usedVariableNames.has(varDef.variable.name.value),\n              ),\n            };\n          }\n        }\n      },\n    },\n  }));\n}\n\nexport const addTypenameToDocument = Object.assign(function <\n  TNode extends ASTNode\n>(\n  doc: TNode\n): TNode {\n  return visit(doc, {\n    SelectionSet: {\n      enter(node, _key, parent) {\n        // Don't add __typename to OperationDefinitions.\n        if (\n          parent &&\n          (parent as OperationDefinitionNode).kind === Kind.OPERATION_DEFINITION\n        ) {\n          return;\n        }\n\n        // No changes if no selections.\n        const { selections } = node;\n        if (!selections) {\n          return;\n        }\n\n        // If selections already have a __typename, or are part of an\n        // introspection query, do nothing.\n        const skip = selections.some(selection => {\n          return (\n            isField(selection) &&\n            (selection.name.value === '__typename' ||\n              selection.name.value.lastIndexOf('__', 0) === 0)\n          );\n        });\n        if (skip) {\n          return;\n        }\n\n        // If this SelectionSet is @export-ed as an input variable, it should\n        // not have a __typename field (see issue #4691).\n        const field = parent as FieldNode;\n        if (\n          isField(field) &&\n          field.directives &&\n          field.directives.some(d => d.name.value === 'export')\n        ) {\n          return;\n        }\n\n        // Create and return a new SelectionSet with a __typename Field.\n        return {\n          ...node,\n          selections: [...selections, TYPENAME_FIELD],\n        };\n      },\n    },\n  });\n}, {\n  added(field: FieldNode): boolean {\n    return field === TYPENAME_FIELD;\n  },\n});\n\nconst connectionRemoveConfig = {\n  test: (directive: DirectiveNode) => {\n    const willRemove = directive.name.value === 'connection';\n    if (willRemove) {\n      if (\n        !directive.arguments ||\n        !directive.arguments.some(arg => arg.name.value === 'key')\n      ) {\n        invariant.warn(\n          'Removing an @connection directive even though it does not have a key. ' +\n            'You may want to use the key parameter to specify a store key.',\n        );\n      }\n    }\n\n    return willRemove;\n  },\n};\n\nexport function removeConnectionDirectiveFromDocument(doc: DocumentNode) {\n  return removeDirectivesFromDocument(\n    [connectionRemoveConfig],\n    checkDocument(doc),\n  );\n}\n\nfunction hasDirectivesInSelectionSet(\n  directives: GetDirectiveConfig[],\n  selectionSet: SelectionSetNode | undefined,\n  nestedCheck = true,\n): boolean {\n  return (\n    !!selectionSet &&\n    selectionSet.selections &&\n    selectionSet.selections.some(selection =>\n      hasDirectivesInSelection(directives, selection, nestedCheck),\n    )\n  );\n}\n\nfunction hasDirectivesInSelection(\n  directives: GetDirectiveConfig[],\n  selection: SelectionNode,\n  nestedCheck = true,\n): boolean {\n  if (!isField(selection)) {\n    return true;\n  }\n\n  if (!selection.directives) {\n    return false;\n  }\n\n  return (\n    selection.directives.some(getDirectiveMatcher(directives)) ||\n    (nestedCheck &&\n      hasDirectivesInSelectionSet(\n        directives,\n        selection.selectionSet,\n        nestedCheck,\n      ))\n  );\n}\n\nfunction getArgumentMatcher(config: RemoveArgumentsConfig[]) {\n  return function argumentMatcher(argument: ArgumentNode) {\n    return config.some(\n      (aConfig: RemoveArgumentsConfig) =>\n        argument.value &&\n        argument.value.kind === Kind.VARIABLE &&\n        argument.value.name &&\n        (aConfig.name === argument.value.name.value ||\n          (aConfig.test && aConfig.test(argument))),\n    );\n  };\n}\n\nexport function removeArgumentsFromDocument(\n  config: RemoveArgumentsConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  const argMatcher = getArgumentMatcher(config);\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      OperationDefinition: {\n        enter(node) {\n          return {\n            ...node,\n            // Remove matching top level variables definitions.\n            variableDefinitions: node.variableDefinitions ? node.variableDefinitions.filter(\n              varDef =>\n                !config.some(arg => arg.name === varDef.variable.name.value),\n            ) : [],\n          };\n        },\n      },\n\n      Field: {\n        enter(node) {\n          // If `remove` is set to true for an argument, and an argument match\n          // is found for a field, remove the field as well.\n          const shouldRemoveField = config.some(argConfig => argConfig.remove);\n\n          if (shouldRemoveField) {\n            let argMatchCount = 0;\n            if (node.arguments) {\n              node.arguments.forEach(arg => {\n                if (argMatcher(arg)) {\n                  argMatchCount += 1;\n                }\n              });\n            }\n\n            if (argMatchCount === 1) {\n              return null;\n            }\n          }\n        },\n      },\n\n      Argument: {\n        enter(node) {\n          // Remove all matching arguments.\n          if (argMatcher(node)) {\n            return null;\n          }\n        },\n      },\n    }),\n  );\n}\n\nexport function removeFragmentSpreadFromDocument(\n  config: RemoveFragmentSpreadConfig[],\n  doc: DocumentNode,\n): DocumentNode | null {\n  function enter(\n    node: FragmentSpreadNode | FragmentDefinitionNode,\n  ): null | void {\n    if (config.some(def => def.name === node.name.value)) {\n      return null;\n    }\n  }\n\n  return nullIfDocIsEmpty(\n    visit(doc, {\n      FragmentSpread: { enter },\n      FragmentDefinition: { enter },\n    }),\n  );\n}\n\n// If the incoming document is a query, return it as is. Otherwise, build a\n// new document containing a query operation based on the selection set\n// of the previous main operation.\nexport function buildQueryFromSelectionSet(\n  document: DocumentNode,\n): DocumentNode {\n  const definition = getMainDefinition(document);\n  const definitionOperation = (<OperationDefinitionNode>definition).operation;\n\n  if (definitionOperation === 'query') {\n    // Already a query, so return the existing document.\n    return document;\n  }\n\n  // Build a new query using the selection set of the main operation.\n  const modifiedDoc = visit(document, {\n    OperationDefinition: {\n      enter(node) {\n        return {\n          ...node,\n          operation: 'query',\n        };\n      },\n    },\n  });\n  return modifiedDoc;\n}\n\n// Remove fields / selection sets that include an @client directive.\nexport function removeClientSetsFromDocument(\n  document: DocumentNode,\n): DocumentNode | null {\n  checkDocument(document);\n\n  let modifiedDoc = removeDirectivesFromDocument(\n    [\n      {\n        test: (directive: DirectiveNode) => directive.name.value === 'client',\n        remove: true,\n      },\n    ],\n    document,\n  );\n\n  return modifiedDoc;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}