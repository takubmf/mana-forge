{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { useCallback, useMemo, useRef } from 'react';\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { useInternalState } from \"./useQuery.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nvar EAGER_METHODS = ['refetch', 'reobserve', 'fetchMore', 'updateQuery', 'startPolling', 'subscribeToMore'];\nexport function useLazyQuery(query, options) {\n  var _a;\n  var execOptionsRef = useRef();\n  var optionsRef = useRef();\n  var queryRef = useRef();\n  var merged = execOptionsRef.current ? mergeOptions(options, execOptionsRef.current) : options;\n  var document = (_a = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a !== void 0 ? _a : query;\n  optionsRef.current = merged;\n  queryRef.current = document;\n  var internalState = useInternalState(useApolloClient(options && options.client), document);\n  var useQueryResult = internalState.useQuery(__assign(__assign({}, merged), {\n    skip: !execOptionsRef.current\n  }));\n  var initialFetchPolicy = useQueryResult.observable.options.initialFetchPolicy || internalState.getDefaultFetchPolicy();\n  var result = Object.assign(useQueryResult, {\n    called: !!execOptionsRef.current\n  });\n  var eagerMethods = useMemo(function () {\n    var eagerMethods = {};\n    var _loop_1 = function (key) {\n      var method = result[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          internalState.forceUpdate();\n        }\n        return method.apply(this, arguments);\n      };\n    };\n    for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {\n      var key = EAGER_METHODS_1[_i];\n      _loop_1(key);\n    }\n    return eagerMethods;\n  }, []);\n  Object.assign(result, eagerMethods);\n  var execute = useCallback(function (executeOptions) {\n    execOptionsRef.current = executeOptions ? __assign(__assign({}, executeOptions), {\n      fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy\n    }) : {\n      fetchPolicy: initialFetchPolicy\n    };\n    var options = mergeOptions(optionsRef.current, __assign({\n      query: queryRef.current\n    }, execOptionsRef.current));\n    var promise = internalState.executeQuery(__assign(__assign({}, options), {\n      skip: false\n    })).then(function (queryResult) {\n      return Object.assign(queryResult, eagerMethods);\n    });\n    promise.catch(function () {});\n    return promise;\n  }, []);\n  return [execute, result];\n}","map":{"version":3,"mappings":"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","names":["useCallback","useMemo","useRef","mergeOptions","useInternalState","useApolloClient","EAGER_METHODS","useLazyQuery","query","options","execOptionsRef","optionsRef","queryRef","merged","current","document","internalState","client","useQueryResult","useQuery","skip","initialFetchPolicy","observable","getDefaultFetchPolicy","result","Object","assign","called","eagerMethods","key","method","create","forceUpdate","apply","arguments","EAGER_METHODS_1","_i","execute","executeOptions","__assign","fetchPolicy","promise","executeQuery","then","queryResult","catch"],"sources":["C:\\Users\\Fistycuffs\\mana-forge\\client\\node_modules\\@apollo\\src\\react\\hooks\\useLazyQuery.ts"],"sourcesContent":["import { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { useCallback, useMemo, useRef } from 'react';\n\nimport { OperationVariables } from '../../core';\nimport { mergeOptions } from '../../utilities';\nimport {\n  LazyQueryHookOptions,\n  LazyQueryResultTuple,\n  QueryResult,\n} from '../types/types';\nimport { useInternalState } from './useQuery';\nimport { useApolloClient } from './useApolloClient';\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  'refetch',\n  'reobserve',\n  'fetchMore',\n  'updateQuery',\n  'startPolling',\n  'subscribeToMore',\n] as const;\n\nexport function useLazyQuery<TData = any, TVariables extends OperationVariables = OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<TData, TVariables>\n): LazyQueryResultTuple<TData, TVariables> {\n  const execOptionsRef = useRef<Partial<LazyQueryHookOptions<TData, TVariables>>>();\n  const optionsRef = useRef<LazyQueryHookOptions<TData, TVariables>>();\n  const queryRef = useRef<DocumentNode | TypedDocumentNode<TData, TVariables>>();\n  const merged = execOptionsRef.current ? mergeOptions(options, execOptionsRef.current) : options;\n  const document = merged?.query ?? query;\n\n  // Use refs to track options and the used query to ensure the `execute` \n  // function remains referentially stable between renders.\n  optionsRef.current = merged;\n  queryRef.current = document;\n\n  const internalState = useInternalState<TData, TVariables>(\n    useApolloClient(options && options.client),\n    document\n  );\n\n  const useQueryResult = internalState.useQuery({\n    ...merged,\n    skip: !execOptionsRef.current,\n  });\n\n  const initialFetchPolicy =\n    useQueryResult.observable.options.initialFetchPolicy ||\n    internalState.getDefaultFetchPolicy();\n\n  const result: QueryResult<TData, TVariables> =\n    Object.assign(useQueryResult, {\n      called: !!execOptionsRef.current,\n    });\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = result[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          internalState.forceUpdate();\n        }\n        return method.apply(this, arguments);\n      };\n    }\n\n    return eagerMethods;\n  }, []);\n\n  Object.assign(result, eagerMethods);\n\n  const execute = useCallback<\n    LazyQueryResultTuple<TData, TVariables>[0]\n  >(executeOptions => {\n    execOptionsRef.current = executeOptions ? {\n      ...executeOptions,\n      fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy,\n    } : {\n      fetchPolicy: initialFetchPolicy,\n    };\n\n    const options = mergeOptions(optionsRef.current, {\n      query: queryRef.current,\n      ...execOptionsRef.current,\n    })\n\n    const promise = internalState\n      .executeQuery({ ...options, skip: false }) \n      .then((queryResult) => Object.assign(queryResult, eagerMethods));\n\n    // Because the return value of `useLazyQuery` is usually floated, we need\n    // to catch the promise to prevent unhandled rejections.\n    promise.catch(() => {});\n\n    return promise;\n  }, []);\n\n  return [execute, result];\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}